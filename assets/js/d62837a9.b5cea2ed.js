"use strict";(self.webpackChunkphasetwo_docs=self.webpackChunkphasetwo_docs||[]).push([[92115],{3061:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"jwts/jwt-security-best-practices","title":"Security Best Practices","description":"JSON Web Tokens (JWTs) are a widely adopted standard for authentication and authorization in modern web applications. Despite some criticism regarding their security, JWTs can provide robust protection when properly implemented.","source":"@site/articles/jwts/jwt-security-best-practices.md","sourceDirName":"jwts","slug":"/jwts/jwt-security-best-practices","permalink":"/articles/jwts/jwt-security-best-practices","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"jwt-security-best-practices","title":"Security Best Practices"},"sidebar":"articles","previous":{"title":"Benefits and Drawbacks of JWTs","permalink":"/articles/jwts/jwt-benefits-drawbacks"}}');var t=n(74848),s=n(28453);const a={id:"jwt-security-best-practices",title:"Security Best Practices"},o="JWT Security Best Practices",l={},c=[{value:"Definitions",id:"definitions",level:2},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Token Transparency and Data Exposure",id:"token-transparency-and-data-exposure",level:3},{value:"Secure Transmission Protocols",id:"secure-transmission-protocols",level:3},{value:"Transport Layer Security",id:"transport-layer-security",level:4},{value:"HTTP Method Considerations",id:"http-method-considerations",level:4},{value:"Cross-Origin Resource Sharing (CORS)",id:"cross-origin-resource-sharing-cors",level:4},{value:"Information Leakage Prevention",id:"information-leakage-prevention",level:3},{value:"Creating Tokens",id:"creating-tokens",level:2},{value:"Signature Algorithm Selection",id:"signature-algorithm-selection",level:3},{value:"Symmetric Signature Algorithms (HMAC)",id:"symmetric-signature-algorithms-hmac",level:4},{value:"Asymmetric Signature Algorithms (RSA/ECC)",id:"asymmetric-signature-algorithms-rsaecc",level:4},{value:"Claims Configuration Best Practices",id:"claims-configuration-best-practices",level:3},{value:"Essential Claim Requirements",id:"essential-claim-requirements",level:4},{value:"Token Revocation Strategies",id:"token-revocation-strategies",level:3},{value:"Short Token Lifetimes",id:"short-token-lifetimes",level:4},{value:"Refresh Token Pattern",id:"refresh-token-pattern",level:4},{value:"Distributed Blacklisting",id:"distributed-blacklisting",level:4},{value:"Emergency Key Rotation",id:"emergency-key-rotation",level:4},{value:"Key Management Framework",id:"key-management-framework",level:3},{value:"Secret Generation Requirements",id:"secret-generation-requirements",level:4},{value:"Key Lifecycle Management",id:"key-lifecycle-management",level:4},{value:"Holding Tokens",id:"holding-tokens",level:2},{value:"Web Application Storage",id:"web-application-storage",level:3},{value:"Secure Cookie Implementation (Recommended)",id:"secure-cookie-implementation-recommended",level:4},{value:"Backend-for-Frontend (BFF) Architecture",id:"backend-for-frontend-bff-architecture",level:4},{value:"Mobile Application Storage",id:"mobile-application-storage",level:3},{value:"iOS Secure Storage",id:"ios-secure-storage",level:4},{value:"Android Secure Storage",id:"android-secure-storage",level:4},{value:"Cross-Platform Solutions",id:"cross-platform-solutions",level:4},{value:"Storage Security Comparison",id:"storage-security-comparison",level:3},{value:"Consuming a JWT",id:"consuming-a-jwt",level:2},{value:"Comprehensive Validation Framework",id:"comprehensive-validation-framework",level:3},{value:"Algorithm Security Verification",id:"algorithm-security-verification",level:3},{value:"Claims Sanitization and Validation",id:"claims-sanitization-and-validation",level:3},{value:"Error Handling Security",id:"error-handling-security",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"References",id:"references",level:2}];function d(e){const i={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"jwt-security-best-practices",children:"JWT Security Best Practices"})}),"\n",(0,t.jsx)(i.p,{children:"JSON Web Tokens (JWTs) are a widely adopted standard for authentication and authorization in modern web applications. Despite some criticism regarding their security, JWTs can provide robust protection when properly implemented."}),"\n",(0,t.jsx)(i.p,{children:"The security of JWTs depends on careful attention to implementation details, proper cryptographic choices, and adherence to established security patterns. When these fundamentals are followed, JWTs offer a powerful and safe mechanism for managing user identity and access control."}),"\n",(0,t.jsx)(i.p,{children:"This comprehensive guide examines how to implement JWTs securely across your entire application stack. We'll explore best practices for token generation, storage, transmission, and validation, ensuring your implementation remains protected against common attack vectors."}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"Note: Security requirements vary significantly between applications. A financial services platform requires different precautions than a social media app. Apply these recommendations based on your specific risk profile and compliance requirements."}),"\n"]}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"Note: Throughout this guide, we'll focus on signed JWTs i.e. the tokens that let you verify they haven't been tampered with (like a wax seal on a letter). We won't cover encrypted JWTs, which hide the actual contents. If you need to keep data secret, encrypted JWTs are a separate topic."}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"definitions",children:"Definitions"}),"\n",(0,t.jsx)(i.p,{children:"Before implementing JWT authentication, it's crucial to understand the core components and their roles:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Token Issuer"}),": The authorization service responsible for generating and signing JWTs. In OAuth terminology, this is typically the Authorization Server (AS)."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Resource Server"}),": The API or service that validates JWTs to authorize access to protected resources. In OAuth, this is the Resource Server (RS) that protects API endpoints."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Client Application"}),": The frontend application (web, mobile, desktop) that obtains tokens from the issuer and presents them to resource servers."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Payload Claims"}),": The data assertions contained within the JWT structure, including both standardized and custom information about the token subject."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,t.jsx)(i.h3,{id:"token-transparency-and-data-exposure",children:"Token Transparency and Data Exposure"}),"\n",(0,t.jsx)(i.p,{children:"The fundamental security characteristic of signed JWTs is their transparency - they function like digital postcards where the content is visible to anyone who possesses the token. Here's an example token that appears cryptic but is easily readable:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiI4NWEwMzg2Ny1kY2NmLTQ4ODItYWRkZS0xYTc5YWVlYzUwZGYiLCJleHAiOjE2NDQ4ODQxODUsImlhdCI6MTY0NDg4MDU4NSwiaXNzIjoiYWNtZS5jb20iLCJzdWIiOiIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDEiLCJqdGkiOiIzZGQ2NDM0ZC03OWE5LTRkMTUtOThiNS03YjUxZGJiMmNkMzEiLCJhdXRoZW50aWNhdGlvblR5cGUiOiJQQVNTV09SRCIsImVtYWlsIjoiYWRtaW5AcGhhc2V0d28uaW8iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXBwbGljYXRpb25JZCI6Ijg1YTAzODY3LWRjY2YtNDg4Mi1hZGRlLTFhNzlhZWVjNTBkZiIsInJvbGVzIjpbImNlbyJdfQ.8DCV8fVizi3Z1EI7tTxp-kChCVhxEReraDIRSdtCMlg\n"})}),"\n",(0,t.jsxs)(i.p,{children:["(You can decode this JWT interactively at ",(0,t.jsx)(i.a,{href:"https://jwt.io/#token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiI4NWEwMzg2Ny1kY2NmLTQ4ODItYWRkZS0xYTc5YWVlYzUwZGYiLCJleHAiOjE2NDQ4ODQxODUsImlhdCI6MTY0NDg4MDU4NSwiaXNzIjoiYWNtZS5jb20iLCJzdWIiOiIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDEiLCJqdGkiOiIzZGQ2NDM0ZC03OWE5LTRkMTUtOThiNS03YjUxZGJiMmNkMzEiLCJhdXRoZW50aWNhdGlvblR5cGUiOiJQQVNTV09SRCIsImVtYWlsIjoiYWRtaW5AcGhhc2V0d28uaW8iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXBwbGljYXRpb25JZCI6Ijg1YTAzODY3LWRjY2YtNDg4Mi1hZGRlLTFhNzlhZWVjNTBkZiIsInJvbGVzIjpbImNlbyJdfQ.8DCV8fVizi3Z1EI7tTxp-kChCVhxEReraDIRSdtCMlg",children:"jwt.io"})," using the secret: ",(0,t.jsx)(i.code,{children:"b7e151628aed2a6abf7158809cf4f3c762e7160efc7e218d3f2c3b394d2d6b8f"}),".)"]}),"\n",(0,t.jsx)(i.p,{children:"This token consists of three base64-encoded segments separated by periods: header metadata, payload claims, and cryptographic signature. The signature guarantees that the content hasn't been modified (integrity), but anyone can decode and read the payload."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Critical Security Principle"}),": Exclude sensitive information such as passwords, social security numbers, payment details, or any confidential business data from JWT payloads. Consider using opaque reference tokens if you need to include sensitive information."]}),"\n",(0,t.jsx)(i.h3,{id:"secure-transmission-protocols",children:"Secure Transmission Protocols"}),"\n",(0,t.jsx)(i.p,{children:"Protecting JWTs during transmission requires multiple layers of security:"}),"\n",(0,t.jsx)(i.h4,{id:"transport-layer-security",children:"Transport Layer Security"}),"\n",(0,t.jsx)(i.p,{children:"Always use TLS 1.2 or later when transmitting tokens. This encrypts the token during network transmission, preventing eavesdropping and man-in-the-middle attacks."}),"\n",(0,t.jsx)(i.h4,{id:"http-method-considerations",children:"HTTP Method Considerations"}),"\n",(0,t.jsx)(i.p,{children:"Avoid including JWTs in URL parameters of GET requests, as these may be:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Logged by web servers, proxies, and CDNs"}),"\n",(0,t.jsx)(i.li,{children:"Cached by browsers and intermediate systems"}),"\n",(0,t.jsx)(i.li,{children:"Leaked through referrer headers"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["Instead, use the standard ",(0,t.jsx)(i.code,{children:"Authorization: Bearer <token>"})," header or secure POST request bodies."]}),"\n",(0,t.jsx)(i.h4,{id:"cross-origin-resource-sharing-cors",children:"Cross-Origin Resource Sharing (CORS)"}),"\n",(0,t.jsxs)(i.p,{children:["When tokens must cross domain boundaries, implement strict CORS policies that explicitly allow only trusted origins. Avoid wildcard (",(0,t.jsx)(i.code,{children:"*"}),") origins in production environments."]}),"\n",(0,t.jsx)(i.h3,{id:"information-leakage-prevention",children:"Information Leakage Prevention"}),"\n",(0,t.jsx)(i.p,{children:"JWT claims can inadvertently reveal system architecture details. Use these strategies to minimize information disclosure:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Replace sequential identifiers (",(0,t.jsx)(i.code,{children:"user_123"}),") with UUIDs or random strings (",(0,t.jsx)(i.code,{children:"usr_8a7b9c2d1e3f"}),")"]}),"\n",(0,t.jsx)(i.li,{children:"Avoid exposing internal service names or database schemas"}),"\n",(0,t.jsx)(i.li,{children:"Use generic error messages that don't reveal validation failure reasons"}),"\n",(0,t.jsx)(i.li,{children:"Implement consistent response timing to prevent timing attacks"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"creating-tokens",children:"Creating Tokens"}),"\n",(0,t.jsx)(i.h3,{id:"signature-algorithm-selection",children:"Signature Algorithm Selection"}),"\n",(0,t.jsx)(i.p,{children:"The choice of signing algorithm impacts both security and performance characteristics of your JWT implementation."}),"\n",(0,t.jsx)(i.h4,{id:"symmetric-signature-algorithms-hmac",children:"Symmetric Signature Algorithms (HMAC)"}),"\n",(0,t.jsx)(i.p,{children:"HMAC-based algorithms (HS256, HS384, HS512) use shared secrets for both signing and verification."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Performance Advantages"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Fastest signing and verification operations"}),"\n",(0,t.jsx)(i.li,{children:"Minimal computational overhead"}),"\n",(0,t.jsx)(i.li,{children:"Suitable for high-throughput scenarios"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Security Considerations"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Requires secure secret distribution to all parties"}),"\n",(0,t.jsx)(i.li,{children:"Any party with the secret can generate valid tokens"}),"\n",(0,t.jsx)(i.li,{children:"Secret compromise affects all token validation"}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"asymmetric-signature-algorithms-rsaecc",children:"Asymmetric Signature Algorithms (RSA/ECC)"}),"\n",(0,t.jsx)(i.p,{children:"Public-key algorithms enable distributed token validation without sharing secrets."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"RSA Algorithms"})," (RS256, RS384, RS512):"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Well-established and widely supported"}),"\n",(0,t.jsx)(i.li,{children:"Larger key sizes required (minimum 2048 bits)"}),"\n",(0,t.jsx)(i.li,{children:"Slower performance, especially for signing operations"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Elliptic Curve Algorithms"})," (ES256, ES384, ES512):"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Modern cryptographic approach"}),"\n",(0,t.jsx)(i.li,{children:"Smaller key sizes with equivalent security"}),"\n",(0,t.jsx)(i.li,{children:"Better performance than RSA"}),"\n",(0,t.jsx)(i.li,{children:"Recommended for new implementations"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Performance Impact"})," (relative to HMAC baseline):"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"HMAC: 1x signing speed, 1x verification speed"}),"\n",(0,t.jsx)(i.li,{children:"ECC: 2.5x signing time, 2x verification time"}),"\n",(0,t.jsx)(i.li,{children:"RSA: 9x signing time, comparable verification speed"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"claims-configuration-best-practices",children:"Claims Configuration Best Practices"}),"\n",(0,t.jsx)(i.p,{children:"While JWT specifications don't mandate specific claims, security-focused implementations should include these registered claims:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-json",children:'{\n  "typ": "JWT", // Token type in header\n  "alg": "ES256", // Algorithm in header\n  "kid": "key_2023_q4", // Key identifier in header\n  "iss": "https://auth.yourcompany.com", // Token issuer\n  "aud": ["api.yourcompany.com"], // Intended audience(s)\n  "sub": "usr_8a7b9c2d1e3f", // Subject (user ID)\n  "exp": 1688127056, // Expiration timestamp\n  "nbf": 1688123456, // Not before timestamp\n  "iat": 1688123456, // Issued at timestamp\n  "jti": "uuid-4a5b6c7d8e9f" // Unique token ID\n}\n'})}),"\n",(0,t.jsx)(i.h4,{id:"essential-claim-requirements",children:"Essential Claim Requirements"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsxs)(i.strong,{children:["Issuer (",(0,t.jsx)(i.code,{children:"iss"}),") Validation"]}),": Use a consistent, unique identifier that doesn't expose internal system details. This enables consumers to verify token origin."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsxs)(i.strong,{children:["Audience (",(0,t.jsx)(i.code,{children:"aud"}),") Specification"]}),": Prevents token misuse across different services by explicitly defining intended recipients. Can be a string or array of strings."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsxs)(i.strong,{children:["Expiration (",(0,t.jsx)(i.code,{children:"exp"}),") Management"]}),": Set aggressive expiration times measured in minutes or hours rather than days. Short-lived tokens reduce the impact of token theft."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsxs)(i.strong,{children:["Unique Identifier (",(0,t.jsx)(i.code,{children:"jti"}),")"]}),": Enables token tracking and revocation. Use cryptographically random values to prevent enumeration attacks."]}),"\n",(0,t.jsx)(i.h3,{id:"token-revocation-strategies",children:"Token Revocation Strategies"}),"\n",(0,t.jsx)(i.p,{children:"Stateless JWTs present revocation challenges that require strategic approaches:"}),"\n",(0,t.jsx)(i.h4,{id:"short-token-lifetimes",children:"Short Token Lifetimes"}),"\n",(0,t.jsx)(i.p,{children:"Issue access tokens with 15-30 minute expiration times. This naturally limits exposure windows while maintaining performance benefits."}),"\n",(0,t.jsx)(i.h4,{id:"refresh-token-pattern",children:"Refresh Token Pattern"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Provide separate, longer-lived refresh tokens for obtaining new access tokens"}),"\n",(0,t.jsx)(i.li,{children:"Store refresh tokens securely and implement revocation lists"}),"\n",(0,t.jsx)(i.li,{children:"Rotate refresh tokens on each use to detect replay attacks"}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"distributed-blacklisting",children:"Distributed Blacklisting"}),"\n",(0,t.jsxs)(i.p,{children:["Maintain a shared cache of revoked token identifiers (",(0,t.jsx)(i.code,{children:"jti"})," claims) that all resource servers check during validation. This introduces some statefulness but enables immediate revocation."]}),"\n",(0,t.jsx)(i.h4,{id:"emergency-key-rotation",children:"Emergency Key Rotation"}),"\n",(0,t.jsx)(i.p,{children:"For security incidents, rotate signing keys to immediately invalidate all outstanding tokens. Implement overlapping key validity periods to ensure seamless transitions."}),"\n",(0,t.jsx)(i.h3,{id:"key-management-framework",children:"Key Management Framework"}),"\n",(0,t.jsx)(i.h4,{id:"secret-generation-requirements",children:"Secret Generation Requirements"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"HMAC Secret Standards"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Minimum length equal to hash output (256 bits for HS256)"}),"\n",(0,t.jsx)(i.li,{children:"Use cryptographically secure random number generators"}),"\n",(0,t.jsx)(i.li,{children:"Never reuse secrets across different applications or environments"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"RSA Key Standards"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Minimum 2048 bits for existing systems"}),"\n",(0,t.jsx)(i.li,{children:"Prefer 3072 bits or higher for new implementations"}),"\n",(0,t.jsx)(i.li,{children:"Generate keys using established cryptographic libraries"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"ECC Key Standards"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Use standardized curves: P-256, P-384, or P-521"}),"\n",(0,t.jsx)(i.li,{children:"Avoid non-standard or experimental curves"}),"\n",(0,t.jsx)(i.li,{children:"Ensure proper random number generation during key creation"}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"key-lifecycle-management",children:"Key Lifecycle Management"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Automated Rotation Schedules"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Implement monthly or quarterly key rotation for production systems"}),"\n",(0,t.jsx)(i.li,{children:"Use deployment automation to minimize manual intervention"}),"\n",(0,t.jsx)(i.li,{children:"Maintain rotation logs for compliance and audit purposes"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Multi-Key Support"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Support multiple concurrent signing keys during rotation periods"}),"\n",(0,t.jsxs)(i.li,{children:["Use ",(0,t.jsx)(i.code,{children:"kid"})," (Key ID) header parameters for key identification"]}),"\n",(0,t.jsx)(i.li,{children:"Implement graceful fallback for old key validation"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Emergency Procedures"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Prepare rapid key rotation procedures for security incidents"}),"\n",(0,t.jsx)(i.li,{children:"Test emergency rotation in non-production environments"}),"\n",(0,t.jsx)(i.li,{children:"Document communication procedures for coordinated key updates"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"holding-tokens",children:"Holding Tokens"}),"\n",(0,t.jsx)(i.p,{children:"Client applications bear responsibility for secure token storage and transmission. Storage strategies must account for the specific capabilities and threat models of different client types."}),"\n",(0,t.jsx)(i.h3,{id:"web-application-storage",children:"Web Application Storage"}),"\n",(0,t.jsx)(i.h4,{id:"secure-cookie-implementation-recommended",children:"Secure Cookie Implementation (Recommended)"}),"\n",(0,t.jsx)(i.p,{children:"Configure cookies with comprehensive security attributes:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-http",children:"Set-Cookie: access_token=<jwt_token>;\n  Secure;\n  HttpOnly;\n  SameSite=Strict;\n  Path=/;\n  Max-Age=3600;\n  Domain=.yourcompany.com\n"})}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Security Benefits"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"HttpOnly"})," prevents JavaScript access, mitigating XSS attacks"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"Secure"})," ensures transmission only over HTTPS connections"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"SameSite=Strict"})," provides CSRF protection for same-site requests"]}),"\n",(0,t.jsx)(i.li,{children:"Automatic transmission eliminates manual header management"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Limitations"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Restricted to same-domain API requests"}),"\n",(0,t.jsx)(i.li,{children:"Requires server-side session infrastructure for cross-domain scenarios"}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"backend-for-frontend-bff-architecture",children:"Backend-for-Frontend (BFF) Architecture"}),"\n",(0,t.jsx)(i.p,{children:"Implement server-side token storage with session-based client communication:"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Implementation Pattern"}),":"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Authentication server issues tokens to your backend service"}),"\n",(0,t.jsx)(i.li,{children:"Backend stores tokens in secure server-side sessions"}),"\n",(0,t.jsx)(i.li,{children:"Client receives session cookies instead of raw tokens"}),"\n",(0,t.jsx)(i.li,{children:"Backend proxies API requests using stored tokens"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Security Advantages"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Complete token isolation from client-side threats"}),"\n",(0,t.jsx)(i.li,{children:"Simplified revocation through session termination"}),"\n",(0,t.jsx)(i.li,{children:"Works across multiple domains and services"}),"\n",(0,t.jsx)(i.li,{children:"Eliminates client-side token exposure"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"mobile-application-storage",children:"Mobile Application Storage"}),"\n",(0,t.jsx)(i.h4,{id:"ios-secure-storage",children:"iOS Secure Storage"}),"\n",(0,t.jsx)(i.p,{children:"Utilize iOS Keychain with appropriate accessibility settings:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-swift",children:'let query: [String: Any] = [\n    kSecClass as String: kSecClassGenericPassword,\n    kSecAttrAccount as String: "jwt_token",\n    kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n    kSecValueData as String: tokenData\n]\n'})}),"\n",(0,t.jsx)(i.h4,{id:"android-secure-storage",children:"Android Secure Storage"}),"\n",(0,t.jsx)(i.p,{children:"Implement EncryptedSharedPreferences or Android Keystore:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-kotlin",children:'val masterKey = MasterKey.Builder(context)\n    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n    .build()\n\nval sharedPreferences = EncryptedSharedPreferences.create(\n    context,\n    "jwt_prefs",\n    masterKey,\n    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n)\n'})}),"\n",(0,t.jsx)(i.h4,{id:"cross-platform-solutions",children:"Cross-Platform Solutions"}),"\n",(0,t.jsx)(i.p,{children:"For React Native and similar frameworks, use specialized secure storage libraries:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"react-native-keychain"})," for iOS/Android keychain access"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"expo-secure-store"})," for Expo applications"]}),"\n",(0,t.jsx)(i.li,{children:"Platform-specific secure storage wrappers"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"storage-security-comparison",children:"Storage Security Comparison"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Storage Method"}),(0,t.jsx)(i.th,{children:"XSS Protection"}),(0,t.jsx)(i.th,{children:"CSRF Protection"}),(0,t.jsx)(i.th,{children:"Cross-Domain Support"}),(0,t.jsx)(i.th,{children:"Revocation Ease"}),(0,t.jsx)(i.th,{children:"Performance Impact"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Secure Cookies"}),(0,t.jsx)(i.td,{children:"\u2705 High"}),(0,t.jsx)(i.td,{children:"\u2705 High"}),(0,t.jsx)(i.td,{children:"\u274c Limited"}),(0,t.jsx)(i.td,{children:"\ud83d\udfe1 Moderate"}),(0,t.jsx)(i.td,{children:"\u2705 Minimal"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"BFF/Sessions"}),(0,t.jsx)(i.td,{children:"\u2705 Complete"}),(0,t.jsx)(i.td,{children:"\u2705 High"}),(0,t.jsx)(i.td,{children:"\u2705 Full"}),(0,t.jsx)(i.td,{children:"\u2705 Easy"}),(0,t.jsx)(i.td,{children:"\ud83d\udfe1 Moderate"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Native Secure Storage"}),(0,t.jsx)(i.td,{children:"\u2705 Complete"}),(0,t.jsx)(i.td,{children:"N/A"}),(0,t.jsx)(i.td,{children:"\u2705 Full"}),(0,t.jsx)(i.td,{children:"\ud83d\udfe1 Moderate"}),(0,t.jsx)(i.td,{children:"\u2705 Minimal"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"In-Memory Storage"}),(0,t.jsx)(i.td,{children:"\ud83d\udfe1 Partial"}),(0,t.jsx)(i.td,{children:"\u2705 High"}),(0,t.jsx)(i.td,{children:"\u2705 Full"}),(0,t.jsx)(i.td,{children:"\u274c Difficult"}),(0,t.jsx)(i.td,{children:"\u2705 Minimal"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Local Storage"}),(0,t.jsx)(i.td,{children:"\u274c Vulnerable"}),(0,t.jsx)(i.td,{children:"\u2705 High"}),(0,t.jsx)(i.td,{children:"\u2705 Full"}),(0,t.jsx)(i.td,{children:"\u274c Difficult"}),(0,t.jsx)(i.td,{children:"\u2705 Minimal"})]})]})]}),"\n",(0,t.jsx)(i.h2,{id:"consuming-a-jwt",children:"Consuming a JWT"}),"\n",(0,t.jsx)(i.p,{children:"Resource servers must implement comprehensive token validation to ensure security and prevent common attack vectors."}),"\n",(0,t.jsx)(i.h3,{id:"comprehensive-validation-framework",children:"Comprehensive Validation Framework"}),"\n",(0,t.jsx)(i.p,{children:"Implement a multi-stage validation process that checks all aspects of token integrity and authenticity:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'def validate_jwt_token(token, expected_issuer, expected_audience, allowed_algorithms):\n    """\n    Comprehensive JWT validation with security-first approach\n    """\n    try:\n        # Stage 1: Structure validation\n        if not token or token.count(\'.\') != 2:\n            raise ValidationError("Invalid token structure")\n\n        header, payload, signature = token.split(\'.\')\n\n        # Stage 2: Header validation\n        header_data = decode_base64_json(header)\n        algorithm = header_data.get(\'alg\')\n\n        if algorithm == \'none\':\n            raise ValidationError("Unsigned tokens rejected")\n\n        if algorithm not in allowed_algorithms:\n            raise ValidationError("Algorithm not permitted")\n\n        # Stage 3: Signature verification\n        public_key = get_public_key(header_data.get(\'kid\'))\n        if not verify_signature(token, public_key, algorithm):\n            raise ValidationError("Signature verification failed")\n\n        # Stage 4: Claims validation\n        claims = decode_base64_json(payload)\n\n        current_time = get_current_timestamp()\n        clock_skew = 60  # Allow 60-second clock skew\n\n        # Timing validations\n        if claims.get(\'exp\', 0) + clock_skew < current_time:\n            raise ValidationError("Token expired")\n\n        if claims.get(\'nbf\', 0) - clock_skew > current_time:\n            raise ValidationError("Token not yet valid")\n\n        # Issuer validation\n        if claims.get(\'iss\') != expected_issuer:\n            raise ValidationError("Invalid issuer")\n\n        # Audience validation\n        token_audiences = claims.get(\'aud\', [])\n        if isinstance(token_audiences, str):\n            token_audiences = [token_audiences]\n\n        if expected_audience not in token_audiences:\n            raise ValidationError("Invalid audience")\n\n        # Optional: Revocation check\n        if is_token_revoked(claims.get(\'jti\')):\n            raise ValidationError("Token revoked")\n\n        return claims\n\n    except ValidationError:\n        raise\n    except Exception as e:\n        # Log technical details internally, return generic error\n        log_security_event("jwt_validation_error", str(e))\n        raise ValidationError("Token validation failed")\n'})}),"\n",(0,t.jsx)(i.h3,{id:"algorithm-security-verification",children:"Algorithm Security Verification"}),"\n",(0,t.jsx)(i.p,{children:"Prevent algorithm confusion attacks by explicitly validating the signing algorithm:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"def verify_algorithm_security(header_algorithm, expected_algorithms):\n    \"\"\"\n    Prevent algorithm downgrade and confusion attacks\n    \"\"\"\n    # Reject unsigned tokens\n    if header_algorithm == 'none':\n        return False\n\n    # Verify algorithm is in allowlist\n    if header_algorithm not in expected_algorithms:\n        return False\n\n    # Prevent HMAC/RSA confusion for asymmetric keys\n    if header_algorithm.startswith('HS') and 'RS' in expected_algorithms:\n        return False\n\n    return True\n"})}),"\n",(0,t.jsx)(i.h3,{id:"claims-sanitization-and-validation",children:"Claims Sanitization and Validation"}),"\n",(0,t.jsx)(i.p,{children:"Sanitize all claim values before using them in business logic:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'def sanitize_jwt_claims(claims):\n    """\n    Sanitize JWT claims for safe application use\n    """\n    sanitized = {}\n\n    # Validate and sanitize user identifier\n    user_id = claims.get(\'sub\')\n    if user_id and is_valid_user_id(user_id):\n        sanitized[\'user_id\'] = escape_sql_injection(user_id)\n\n    # Validate and sanitize custom claims\n    for claim_name, claim_value in claims.items():\n        if claim_name in ALLOWED_CUSTOM_CLAIMS:\n            sanitized[claim_name] = sanitize_claim_value(claim_value)\n\n    return sanitized\n'})}),"\n",(0,t.jsx)(i.h3,{id:"error-handling-security",children:"Error Handling Security"}),"\n",(0,t.jsx)(i.p,{children:"Implement consistent error responses that don't leak validation details:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'def handle_jwt_validation_error(error_type, request_context):\n    """\n    Provide consistent error responses regardless of validation failure type\n    """\n    # Log detailed error internally\n    log_security_event("jwt_validation_failure", {\n        "error_type": error_type,\n        "client_ip": request_context.get(\'client_ip\'),\n        "timestamp": get_current_timestamp(),\n        "user_agent": request_context.get(\'user_agent\')\n    })\n\n    # Return generic error to client\n    return {\n        "error": "invalid_token",\n        "error_description": "The provided token is invalid"\n    }, 401\n'})}),"\n",(0,t.jsx)(i.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(i.p,{children:"Optimize validation performance while maintaining security:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Cache public keys"})," with appropriate TTL values"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Implement connection pooling"})," for key retrieval services"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Use efficient JSON parsing"})," libraries"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Cache validation results"})," for identical tokens (with short TTL)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Implement circuit breakers"})," for external key services"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(i.p,{children:"Building secure JWT authentication involves methodically addressing each phase of the token lifecycle. This guide has covered key strategies and patterns that you can use to develop production systems that effectively utilize JWTs while maintaining robust security."}),"\n",(0,t.jsx)(i.p,{children:"Working with JWTs requires a solid grasp of their core concepts, proper validation approaches, and disciplined operational practices. To maintain security over time, implement regular reviews, monitor for new threats, and update your implementation as industry best practices evolve."}),"\n",(0,t.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://tools.ietf.org/html/rfc7519",children:"RFC 7519: JSON Web Token (JWT)"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://tools.ietf.org/html/rfc7515",children:"RFC 7515: JSON Web Signature (JWS)"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://tools.ietf.org/html/rfc8725",children:"RFC 8725: JSON Web Token Best Current Practices"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html",children:"OWASP JWT Security Cheat Sheet"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://tools.ietf.org/html/rfc7517",children:"JSON Web Key (JWK) Specification"})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>o});var r=n(96540);const t={},s=r.createContext(t);function a(e){const i=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);